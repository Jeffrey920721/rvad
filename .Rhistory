rmse = rmse))
}
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
}
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
max_consecutive_na <- 30
max_na <- 0.2
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
az <-  azimuth[elev_ang == elevs[e]]
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
warnings()
rle(is.na(c(1, 1, 1, )))
rle(is.na(c(1, 1, 1, 1)))
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- suppressWarnings(max(rle_nas$lengths[rle_nas$values == TRUE]))
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
fit
spd
plot(spd)
plot(spd[!is.na(spd)])
plot(r2)
plot(spd[!is.na(spd) & r2 > 0.6])
plot(r2, spd)
plot(rmse, r)
plot(rmse, r2)
range
str(range)
expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
vad
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
source('~/rvad/R/fit_qc.R', echo=TRUE)
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
r2_min <- 0.8
NA > 0.2
fit_qc <- function(r2, r2_min = 0.8) {
r2 >= r2_min & !is.na(r2)
}
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad
library(ggplot2)
ggplot(vad, aes(range, spd)) + geom_point()
library(ncdf4)
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
vad_p <- read.csv("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv")
vad_p <- read.csv("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv", na.strings = "-9999")
vad_p <- data.table::fread("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv", na.strings = "-9999", )
View(vad_p)
library(ggplot2)
str(vad_p)
ggplot(subset(vad_p, !is.na(spd)), aes(ht, spd)) +
geom_point() +
coord_flip()
subset(vad_p, !is.na(spd))
max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
fit_qc <- function(r2, r2_min = 0.8) {
r2 >= r2_min & !is.na(r2)
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- suppressWarnings(max(rle_nas$lengths[rle_nas$values == TRUE]))
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
#   - r2 no NA
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))
beam_propagation <- function(range, elev_ang, R = 6371000, Rp = 4*R/3) {
#Calcula la altura teniendo en cuenta la apróximación
ht <- sqrt(range^2 + Rp^2 + 2*range*Rp*sin(pi*elev_ang/180)) - Rp
#Calcula el rango horizontal
rh <- range*cos(pi*elev_ang/180)
#Calcula el angulo de elevación efectivo teniendo en cuenta la aproximación
lea <- pi*elev_ang/180 + atan((range*cos(pi*elev_ang/180))/(range*sin(pi*elev_ang/180) + Rp))
return(list(ht = ht, rh = rh, lea = lea))
}
vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))
subset(vad_p, !is_na(spd))
subset(vad_p, !is.na(spd))
vad_p <- subset(vad_p, !is.na(spd))
View(vad_p)
ggplot(subset(vad_p, !is.na(spd)), aes(ht, spd)) +
geom_point(aes(color = rs)) +
coord_flip()
vad_p <- data.table::fread("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv", na.strings = "-9999", )
subset(vad_p, rs < 0.8)
subset(vad_p, rs < 0.8 & !is.na(spd))
ggplot(subset(vad_p, !is.na(spd)), aes(rs)) + geom_density()
