for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
fit <- ring_fit(vr[r, elev_ang == elevs[e]],
azimuth[elev_ang == elevs[e]],
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
field  = 'Vda'    #Nombre de la variable en el archivo de datos
k
vr[r, elev_ang == elevs[e]]
ring <- vr
nas <- is.na(ring)
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
ring
str(ring)
ring <- vr[r, elev_ang == elevs[e]]
nas <- is.na(ring)
nas
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
fit
azimuth[elev_ang == elevs[e]]
r
e
elev_ang
elev_ang == elevs[e]
sum(elev_ang == elevs[e])
is.na(is.na(azimuth))
sum(is.na(azimuth))
sum(is.na(azimuth[elev_ang == elevs[e]]))
str(azimuth)
str(elev_ang)
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
str(azimuth)
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
fit <- ring_fit(vr[r, elev_ang == elevs[e]],
azimuth[elev_ang == elevs[e]],
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
spd
plot(spd)
plot(spd[!is.na(r2)])
r2
plot(spd[!is.na(r2) & r2 > 0.7])
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd = spd,
dir = dir,
r2 = r2,
rmse = rmse))
}
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
fit <- ring_fit(vr[r, elev_ang == elevs[e]],
azimuth[elev_ang == elevs[e]],
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
k
ring <- vr[r, elev_ang == elevs[e]]
plot(ring)
ring
ring <- vr[r, elev_ang == elevs[e]]
rle(c(1, NA, NA, 2))
rle(c(1, NA, NA, 2, 2))
rle(c(1, Inf, Inf, 2, 2))
rle(c(1,1, 1, 2, 2, 1, 1))
NA == NA
ring2 <- ring
ring2[is.na(ring2)] <- Inf
ring2
rle(ring2)
rle(is.na(c(1,1, NA, NA, 2)))
rle(is.na(c(1,1, NA, NA, 2, NA, NA, NA)))
azimuth
azimuth <- azimuth[elev_ang == elevs[e]]
str(azimuth)
azimuth[!is.na(ring)]
plot(azimuth)
diff(azimuth)
plot(diff(azimuth))
range(diff(azimuth))
length(azimuth)
r
e
r
e = 3
ring <- vr[r, elev_ang == elevs[e]]
plot(ring)
ring
e
r
r = 10
ring <- vr[r, elev_ang == elevs[e]]
plot(ring)
sum(is.na(ring))
azimuth <- ncvar_get(radar, 'azimuth')
azimuth[elev_ang == elevs[e]]
azimuth <- azimuth[elev_ang == elevs[e]]
diff(azimuth[!is.na(ring)])
range(diff(azimuth[!is.na(ring)]))
rle(is.na(ring))
360/length(azimuth)
rle(is.na(ring))
max_consecutive_na*360/length(azimuth)
max_consecutive_na = 30
max_consecutive_na = 30
# Assumes (quasi) regular grid
max_consecutive_na*length(azimuth)/360
rle(is.na(ring))
rle_nas <- rle(is.na(ring))
rle_nas <- rle(is.na(ring))
rle_nas$lengths[rle_nas$values == TRUE]
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == lengh(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
}
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
max_consecutive_na <- 30
max_na <- 0.2
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
az <-  azimuth[elev_ang == elevs[e]]
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
ring
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- max(rle_nas$lengths[rle_nas$values == TRUE])
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
warnings()
rle(is.na(c(1, 1, 1, )))
rle(is.na(c(1, 1, 1, 1)))
ring_qc <- function(ring, azimuth, max_na = 0.2, max_consecutive_na = 30) {
nas <- is.na(ring)
n_nas <- sum(nas)
N <- length(ring)
if (n_nas/N > max_na) {
return(rep(NA, N))
}
# Assumes (quasi) regular grid
max_consecutive_na <- max_consecutive_na*length(azimuth)/360
rle_nas <- rle(is.na(ring))
max_rle_nas <- suppressWarnings(max(rle_nas$lengths[rle_nas$values == TRUE]))
if (max_rle_nas >= max_consecutive_na) {
return(rep(NA, N))
}
return(ring)
}
ring_fit <- function(ring, azimuth, elev) {
nas <- is.na(ring)
if (sum(nas) == length(ring)) {
return(list(spd  = NA,
dir  = NA,
r2   = NA,
rmse = NA))
}
fit <- .lm.fit(cbind(1, cos(azimuth*pi/180), sin(azimuth*pi/180))[!nas, , drop = FALSE],
ring[!nas])
rmse <- sd(fit$residuals)
r2 <- 1 - var(fit$residuals)/var(ring[!nas])
a <- fit$coefficients[2]
b <- fit$coefficients[3]
spd <- sqrt(a^2 + b^2)/cos(elev*pi/180)
if (b < 0) {
dir <- pi/2 - atan(a/b)*180/pi
} else {
dir <- 3*pi/2 - atan(a/b)*180/pi
}
return(list(spd  = spd,
dir  = dir,
r2   = r2,
rmse = rmse))
}
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring,
az,
elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
fit
spd
plot(spd)
plot(spd[!is.na(spd)])
plot(r2)
plot(spd[!is.na(spd) & r2 > 0.6])
plot(r2, spd)
plot(rmse, r)
plot(rmse, r2)
range
str(range)
expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
vad
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
source('~/rvad/R/fit_qc.R', echo=TRUE)
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
r2_min <- 0.8
NA > 0.2
fit_qc <- function(r2, r2_min = 0.8) {
r2 >= r2_min & !is.na(r2)
}
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad
library(ggplot2)
ggplot(vad, aes(range, spd)) + geom_point()
