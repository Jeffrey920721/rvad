plot(spd[!is.na(spd) & r2 > 0.6])
plot(r2, spd)
plot(rmse, r)
plot(rmse, r2)
range
str(range)
expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
vad
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
source('~/rvad/R/fit_qc.R', echo=TRUE)
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
r2_min <- 0.8
NA > 0.2
fit_qc <- function(r2, r2_min = 0.8) {
r2 >= r2_min & !is.na(r2)
}
vad <- expand.grid(range = range, elevs = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad
library(ggplot2)
ggplot(vad, aes(range, spd)) + geom_point()
library(ncdf4)
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8
VAD <- function(range, elev_ang, vr) {
# 1. Filtrar los datos según rango mínimo y máximo
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
#   - r2 no NA
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))
}
library(ncdf4)
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8
radadr
radar
range
str(range)
str(elev_ang)
str(vr)
dims <- expand.grid(range = range, elev_ang = elevs)
V <- expand.grid(range = range, elev_ang = elevs)
V$vd <- c(vr)
V <- expand.grid(range = range, elev_ang = elevs)
V$vd <- c(vr)
radar <- metR::ReadNetCDF("radar.nc", our = "vars")
radar <- metR::ReadNetCDF("radar.nc", out = "vars")
str(radar, 1)
str(radar$dimensions)
radar <- metR::ReadNetCDF("radar.nc", c("Vda", "elevation", "azimuth"))
str(radar)
radar
radar
library(ggplot2)
ggplot(radar[elevation == unique(elevation)[3]], aes(range, azimuth)) + geom_raster(aes(fill = Vda))
ggplot(radar[elevation == unique(elevation)[3]], aes(range, azimuth)) + geom_point(aes(color = Vda, size = range)) + coord_polar()
ggplot(radar[elevation == unique(elevation)[3]], aes(range, azimuth)) + geom_point(aes(color = Vda, size = range))
dev.off()
ggplot(radar[elevation == unique(elevation)[3]], aes(range, azimuth)) + geom_point(aes(color = Vda))
ggplot(radar[elevation == unique(elevation)[3]], aes(range, azimuth)) + geom_raster(aes(fill = Vda)) + metR::scale_fill_divergent()
VAD <- function(range, elev_ang, vr) {
# 1. Filtrar los datos según rango mínimo y máximo
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
#   - r2 no NA
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))
}
vad <- VAD(range, elev_ang, vr)
devtools::load_all(".")
devtools::load_all(".")
warnings()
devtools::load_all(".")
library(ncdf4)
radar <- metR::ReadNetCDF("radar.nc", c("Vda", "elevation", "azimuth"))
radar <- nc_open("radar.nc")
vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')
this_elev <- unique(elev_ang)[3]
this_range <- range[1]
which_elev <- elev_ang == this_elev
max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8
V <- expand.grid(range = range, elev_ang = unique_)
V$vd <- c(vr)
vad <- VAD(range, elev_ang, vr)
va
vad
str(vad)
library(ggplot2)
View(vad)
debugSource('~/Documents/rvad/R/VAD.R', echo=TRUE)
vad <- VAD(range, elev_ang, vr)
devtools::load_all(".")
vad <- VAD(range, elev_ang, vr)
View(vad)
devtools::load_all(".")
vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))
vad
View(vad)
devtools::load_all(".")
vad <- VAD(range, elev_ang, vr)
str(vad)
str(range)
elev_ang <- c(ncvar_get(radar, 'elevation'))
range <- c(ncvar_get(radar, 'range'))
azimuth <- c(ncvar_get(radar, 'azimuth'))
vad <- VAD(range, elev_ang, vr)
str(vad)
library(ggplot2)
ggplot(vad, aes())
ggplot(vad, aes(ht, spd)) +
geom_point8)
ggplot(vad, aes(ht, spd)) +
geom_point()
ggplot(vad, aes(spd, ht)) +
geom_point()
str(vr)
str(range)
radar <- nc_open("radar.nc")
radar
vad_python <- data.table::fread("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv")
vad_python
vad_python <- data.table::fread("elev_vda-2016-01-14T06:00:05Z_INTA_Parana.csv", na.strings = "-9999")
vad_python
ggplot(vad_python, aes(spd, ht)) +
geom_point()
ggplot(vad_python[complete.cases(vad_python)], aes(spd, ht)) +
geom_point()
vad_python[, unique(hg)]
vad_python[, unique(ht)]
hts <- vad_python[, unique(ht)]
vad_python <- vad_python[complete.cases(vad_python)]
hts <- vad_python[, unique(ht)]
hts
unique(vad$ht)
uniqueN(vad$ht)
library(data.table)
uniqueN(vad$ht)
uniqueN(vad_python$ht)
radar <- metR::ReadNetCDF("radar.nc", out = "vars")
radar <- metR::ReadNetCDF("radar.nc", c("range", "azimuth", "elevation", "Vda"))
radar <- nc_open("radar.nc")
radar <- metR::ReadNetCDF("radar.nc", out = "vars")
radar$dimensions
str(radar$dimensions, 1)
str(radar$dimensions, 1)
radar <- metR::ReadNetCDF("radar.nc",
c("azimuth", "elevation", "Vda"))
radar
radar
radar[complete.cases(radar)][, ring_fit(Vda, azimuth, elevation)]
vda <- radar[complete.cases(radar)][, ring_fit(Vda, azimuth, elevation)]
vda <- radar[complete.cases(radar)][, ring_fit(Vda, azimuth, elevation),
by = .(range, elevation)]
vda
vda[, beam_propagation(range, elevation)]
vda[, ht := beam_propagation(range, elevation)$ht]
vda
ggplot(vda, aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.5], aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.5 & spd < 20], aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.5 & spd < 20 & ht < 20000], aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.5 & spd < 20 & ht < 3000], aes(spd, ht)) +
geom_point(  )
radar <- metR::ReadNetCDF("radar.nc",
c("azimuth", "elevation", "Vda"))
radar
radar
ggplot(vda[r2 > 0.7 & spd < 20 & ht < 3000], aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.8 & spd < 20 & ht < 3000], aes(spd, ht)) +
geom_point(  )
ggplot(vda[r2 > 0.8 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point(  )
ggplot(vda[r2 > 0.8 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point(  ) +
geom_smooth()
vda
ggplot(vda[r2 > 0.8 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse))
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse))
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1)
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.05)
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.05, N = 100)
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.05, n = 200)
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200)
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/r2), span = 0.1, n = 200) +
NULL
ggplot(vda[r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200) +
coord_flip()
library(data.table)
ggplot(vda[range %between% c(500, 40000) r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200) +
coord_flip()
ggplot(vda[range %between% c(500, 40000) & r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200) +
coord_flip()
ggplot(vda[range > 40000 & r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200) +
coord_flip()
ggplot(vda[range > 500 & r2 > 0.8 & r2 != 1 & spd < 20 & ht < 3000], aes(ht, spd)) +
geom_point() +
geom_smooth(aes(weight = 1/rmse), span = 0.1, n = 200) +
coord_flip()
radar
vr <- radar$Vda
range <- radar$range
vr <- radar$Vda
range <- radar$range
azimuth <- radar$azimuth
elev_ang <- radar$elevation
vol <- data.frame(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
split(vol, list(vol$range, vol$elev_ang))
vol_split <- split(vol, list(vol$range, vol$elev_ang))
vols_split
str(vol_split, 1)
vol <- data.table::data.table(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
vol[, vr_qc := ring_qc(ring, azimuth, max_na = max_na, max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na, max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vol <- data.table::data.table(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
vol
vol
max_na
max_consecutive_na
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
source('~/Documents/rvad/R/ring_qc.R', echo=TRUE)
vol[range == range[1] & elev_ang == elev_ang[1] ]
vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth)]
vol[range == range[1] & elev_ang == elev_ang[1], vr_qc :=  ring_qc(vr, azimuth)]
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
source('~/Documents/rvad/R/ring_qc.R', echo=TRUE)
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vol <- data.table::data.table(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
for (r in seq_along(range)) {
for (e in seq_along(elevs)) {
k <- k + 1
ring <- vr[r, elev_ang == elevs[e]]
az <-  azimuth[elev_ang == elevs[e]]
# 3. Control de calidad
#   - Cantidad de NAs
#   - Cantidad de NAs consecutivos
#   - Posible filtro pasa bajo
ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)
# 5. Si todo anda bien, haccer el fit
fit <- ring_fit(ring, az, elevs[e])
spd[k] <- fit$spd
dir[k] <- fit$dir
r2[k] <- fit$r2
rmse[k] <- fit$rmse
}
}
t <- vol[,  ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
devtools::load_all(".")
t <- vol[,  ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vol <- data.table::data.table(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
val
vol
t <- vol[, ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(t)
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
stR(t)
str(t)
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
t
remove(ring_qc())
remove(ring_qc)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(t)
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(t)
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(t)
devtools::load_all(".")
t <- vol[range == range[1] & elev_ang == elev_ang[1], ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(T)
str(t)
t <- vol[, ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
str(t)
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vol
vr[, mean(is.na(vr_qc) & !is.na(vr))]
vol[, mean(is.na(vr_qc) & !is.na(vr))]
vol[, sum(is.na(vr_qc) & !is.na(vr))]
vol[, ring_fit(vr, azimuth, elev_ang), by = .(range, elev_ang)]
devtools::load_all(".")
vol[, ring_fit(vr, azimuth, elev_ang), by = .(range, elev_ang)]
vad <- vol[, ring_fit(vr, azimuth, elev_ang), by = .(range, elev_ang)]
vad <- vol[, ring_fit(vr_qc, azimuth, elev_ang), by = .(range, elev_ang)]
vad
vad[, ht := beam_propagation(vad$range, elev_ang = vad$elev_ang)$ht]
ggplot(vad, aes(spd, ht)) +
geom_point()
ggplot(vad[complete.cases(vad)], aes(spd, ht)) +
geom_point()
VAD <- function(vr, azimuth, range, elev_ang) {
vol <- data.table::data.table(vr = vr, azimuth = azimuth, range = range, elev_ang = elev_ang)
# 1. Filtrar los datos según rango mínimo y máximo
# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)
k <- 0
vol[, vr_qc := ring_qc(vr, azimuth, max_na = max_na,
max_consecutive_na = max_consecutive_na),
by = .(range, elev_ang)]
vad <- vol[, ring_fit(vr_qc, azimuth, elev_ang), by = .(range, elev_ang)]
vad[, ht := beam_propagation(vad$range, elev_ang = vad$elev_ang)$ht]
vad <- vad[!fit_qc(vad$r2, r2_min), ]
# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
#   - r2 no NA
vad <- vad[fit_qc(vad$r2, r2_min), ]
vad
}
radar
radar[, VAD(Vda, azimuth, range, elevation)]
devtools::load_all(".")
radar[, VAD(Vda, azimuth, range, elevation)]
devtools::load_all(".")
devtools::load_all(".")
radar[, VAD(Vda, azimuth, range, elevation)]
devtools::load_all(".")
library(ggplot2)
library(data.table)
radar <- metR::ReadNetCDF("radar.nc",
c("azimuth", "elevation", "Vda"))
radar[, VAD(Vda, azimuth, range, elevation)]
devtools::load_all(".")
radar[, VAD(Vda, azimuth, range, elevation)]
