library(ncdf4)


radar <- nc_open("radar.nc")

vr <- ncvar_get(radar, 'Vda')
elev_ang <- ncvar_get(radar, 'elevation')
range <- ncvar_get(radar, 'range')
azimuth <- ncvar_get(radar, 'azimuth')
cos_phi <- cos((azimuth*pi)/180)
sin_phi <- sin((azimuth*pi)/180)
start_index <-  ncvar_get(radar, 'sweep_start_ray_index')
end_index <-  ncvar_get(radar, 'sweep_end_ray_index')

this_elev <- unique(elev_ang)[3]
this_range <- range[1]

which_elev <- elev_ang == this_elev

max_consecutive_na <- 30
max_na <- 0.2
r2_min <- 0.8



# 1. Filtrar los datos según rango mínimo y máximo

# 2. Para cada rango y elevación,
elevs <- unique(elev_ang)
K <- length(range)*length(elevs)
spd <- rep(NA, length = K)
dir <- rep(NA, length = K)
r2 <- rep(NA, length = K)
rmse <- rep(NA, length = K)

k <- 0
for (r in seq_along(range)) {
  for (e in seq_along(elevs)) {
    k <- k + 1
    ring <- vr[r, elev_ang == elevs[e]]
    az <-  azimuth[elev_ang == elevs[e]]
    # 3. Control de calidad
    #   - Cantidad de NAs
    #   - Cantidad de NAs consecutivos
    #   - Posible filtro pasa bajo

    ring <- ring_qc(ring, az, max_na = max_na, max_consecutive_na = max_consecutive_na)

    # 5. Si todo anda bien, haccer el fit
    fit <- ring_fit(ring, az, elevs[e])

    spd[k] <- fit$spd
    dir[k] <- fit$dir
    r2[k] <- fit$r2
    rmse[k] <- fit$rmse
  }
}

vad <- expand.grid(range = range, elev_ang = elevs)
vad[["spd"]] <- spd
vad[["dir"]] <- dir
vad[["r2"]] <- r2
vad[["rmse"]] <- rmse


# 6. Control de calidad sobre el fit
#   - r2 mayor a un valor
#   - r2 no NA
vad <- vad[fit_qc(vad$r2, r2_min), ]

vad <- cbind(vad, beam_propagation(vad$range, elev_ang = vad$elev_ang))




# Parametros

field  = 'Vda'    #Nombre de la variable en el archivo de datos
angmin = 2        #Ángulo de elevación mínimo expresado como indice y empezando en 0
angmax = 7        #Ángulo de elevación máximo expresado como indice
rint   = 0.3      #Radio interior de la arandala a calcular en Km
rext   = 40.0     #Radio exterior de la arandela a calcular
maxgap = 30       #Máximo gap sin datos permitido, en grados
maxNaN = 72       #Cantidad de de datos faltantes en un anillo
rmin   = 0.8      #R cuadrado mínimo para que el fit del anillo sea válido
lpf    = 'False'  #Usa o no filtro pasa bajo
N      = 12       #Cantidad de datos a usar en el filtro, tiene que ser par!
